/*
 * Samsung TV Remote for Flipper Zero
 *
 * A redesigned, more intuitive GUI for the Samsung TV remote application.
 * This version features a vertical layout designed to be used when holding
 * the Flipper sideways (rotated +90 degrees), with the IR sensor pointing at the TV.
 * This application showcases writting custom IR codes with the Flipper SDK.
 * Author: Tyler Berndt
 * Website: https://purplefox.io
 */

#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <notification/notification.h>
#include <notification/notification_messages.h> // For notification sequences
#include <gui/view_dispatcher.h>
#include <gui/view.h>
#include <gui/icon.h>
#include <gui/modules/widget.h> // Needed for the About screen widget

// The SDK infrared library
#include "infrared_signal.h"
// Header for icons generated by the build system from the 'images' folder
#include "samsung_icons.h"

// --- App Views ---
typedef enum {
    AppViewRemote,
    AppViewAbout,
} AppView;

// --- Button Definitions ---
typedef enum {
    Button_Power,
    Button_Up,
    Button_Left,
    Button_Enter,
    Button_Right,
    Button_Down,
    Button_Volume_Up,
    Button_Channel_Up,
    Button_Volume_Down,
    Button_Channel_Down,
    Button_Netflix,
    Button_Amazon,
    Button_Return,
    Button_Mute,
    Button_About,
    Button_Max, // Represents the total number of buttons
} TvButton;

// Struct to define the properties and layout of a single remote button
typedef struct {
    const char* label; // Text label for the button (or NULL if using icon)
    const Icon* icon; // Icon for the button (or NULL if using text)
    uint8_t x, y, w, h; // Position (x,y) and size (width, height)
    // Navigation links to other buttons for D-Pad controls
    TvButton nav_up;
    TvButton nav_down;
    TvButton nav_left;
    TvButton nav_right;
} RemoteButtonDef;

// --- Remote Layout Definition ---
// A vertical, single-column layout designed to be viewed with the Flipper
// held sideways (rotated +90 degrees). Navigation links are corrected for new logic.
static const RemoteButtonDef button_defs[Button_Max] = {
    // ID                 Label       Icon                         X   Y   W   H   Up (phys Left)      Down (phys Right)   Left (phys Down)    Right (phys Up)
    [Button_Power]      = {"PWR",      NULL,                         16,  2, 32,  8, Button_Power,       Button_Enter,       Button_Power,       Button_Power},

    // D-Pad
    [Button_Up]         = {NULL,       &I_up7x4,                     28, 14,  7,  4, Button_Power,       Button_Enter,       Button_Up,          Button_Up},
    [Button_Enter]      = {"OK",       NULL,                         20, 22, 24,  9, Button_Up,          Button_Volume_Up,   Button_Left,        Button_Right},
    [Button_Left]       = {NULL,       &I_left7x4,                   10, 23,  7,  4, Button_Enter,       Button_Enter,       Button_Left,        Button_Enter},
    [Button_Right]      = {NULL,       &I_right7x4,                  47, 23,  7,  4, Button_Enter,       Button_Enter,       Button_Enter,       Button_Right},
    [Button_Down]       = {NULL,       &I_down7x4,                   28, 34,  7,  4, Button_Enter,       Button_Volume_Up,   Button_Down,        Button_Down},

    // Volume and Channel Rockers (in two columns)
    [Button_Volume_Up]  = {NULL,       &I_volup24x21,      5, 45, 24, 21, Button_Enter,       Button_Volume_Down, Button_Volume_Up,   Button_Channel_Up},
    [Button_Channel_Up] = {NULL,       &I_chup24x21,                 35, 45, 24, 21, Button_Enter,       Button_Channel_Down,Button_Volume_Up,   Button_Channel_Up},

    [Button_Volume_Down]= {NULL,       &I_voldown24x21,        5, 68, 24, 21, Button_Volume_Up,   Button_Netflix,     Button_Volume_Down, Button_Channel_Down},
    [Button_Channel_Down]={NULL,       &I_chdown24x21,               35, 68, 24, 21, Button_Channel_Up,  Button_Amazon,      Button_Volume_Down, Button_Channel_Down},

    // App Buttons
    [Button_Netflix]    = {"Netflx",  NULL,                         5, 92, 24, 10, Button_Volume_Down, Button_Return,      Button_Netflix,     Button_Amazon},
    [Button_Amazon]     = {"Prime",    NULL,                         35, 92, 24, 10, Button_Channel_Down,Button_Return,      Button_Netflix,     Button_Amazon},

    // Bottom Row
    [Button_Return]     = {"Ret",   NULL,                         5, 105, 24, 10, Button_Netflix,     Button_About,       Button_Return,      Button_Mute},
    [Button_Mute]       = {"Mute",     NULL,                         35, 105, 24, 10, Button_Amazon,      Button_About,       Button_Return,      Button_Mute},

    // About Button
    [Button_About]      = {"About",    NULL,                         5, 118, 54, 8, Button_Return,      Button_About,       Button_About,       Button_About},
};

// --- App Structures ---

// Model for the main view, holds the currently selected button
typedef struct {
    TvButton current_button;
} RemoteViewModel;

// Main application structure
typedef struct {
    ViewDispatcher* view_dispatcher;
    View* remote_view;
    Widget* about_widget;
    NotificationApp* notifications;
    AppView current_view; // State variable to track the current view
} App;

// --- Function Prototypes ---
static void send_ir_code(TvButton button, NotificationApp* notifications);
static bool about_widget_input_callback(InputEvent* event, void* context);

// --- Core Functions ---

/**
 * @brief Draws the remote control UI on the canvas.
 * @param canvas The canvas to draw on.
 * @param model The view model containing the current state.
 */
static void app_draw_callback(Canvas* canvas, void* model) {
    RemoteViewModel* view_model = model;
    canvas_clear(canvas);

    // Draw all buttons in their unselected state first
    for(int i = 0; i < Button_Max; i++) {
        const RemoteButtonDef* btn = &button_defs[i];
        canvas_set_color(canvas, ColorBlack);
        if(btn->icon) {
            canvas_draw_icon(canvas, btn->x, btn->y, btn->icon);
        } else {
            canvas_draw_rframe(canvas, btn->x, btn->y, btn->w, btn->h, 3);
            canvas_set_font(canvas, FontSecondary);
            canvas_draw_str_aligned(
                canvas, btn->x + btn->w / 2, btn->y + btn->h / 2, AlignCenter, AlignCenter, btn->label);
        }
    }

    // Draw the selected button over the top to fix highlighting issues
    const RemoteButtonDef* selected_btn = &button_defs[view_model->current_button];
    canvas_set_color(canvas, ColorBlack);
    if(selected_btn->icon) {
        canvas_draw_box(canvas, selected_btn->x - 2, selected_btn->y - 2, selected_btn->w + 4, selected_btn->h + 4);
        canvas_set_color(canvas, ColorWhite);
        canvas_draw_icon(canvas, selected_btn->x, selected_btn->y, selected_btn->icon);
    } else {
        canvas_draw_rbox(canvas, selected_btn->x, selected_btn->y, selected_btn->w, selected_btn->h, 3);
        canvas_set_color(canvas, ColorWhite);
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str_aligned(
            canvas,
            selected_btn->x + selected_btn->w / 2,
            selected_btn->y + selected_btn->h / 2,
            AlignCenter,
            AlignCenter,
            selected_btn->label);
    }
}

/**
 * @brief Handles user input from the D-pad and buttons, remapping for vertical orientation.
 * @param event The input event.
 * @param context The application context.
 * @return True if the event was handled, false otherwise.
 */
static bool app_input_callback(InputEvent* event, void* context) {
    App* app = context;
    bool handled = false;

    if(event->type != InputTypeShort && event->type != InputTypeRepeat) {
        return false;
    }

    if(event->key == InputKeyBack) {
        // Only exit if we are on the main remote view
        if(app->current_view == AppViewRemote) {
            view_dispatcher_stop(app->view_dispatcher);
        }
        handled = true;
    } else if(event->key == InputKeyOk) {
        RemoteViewModel* model = view_get_model(app->remote_view);
        if(model->current_button == Button_About) {
            app->current_view = AppViewAbout;
            view_dispatcher_switch_to_view(app->view_dispatcher, AppViewAbout);
        } else {
            send_ir_code(model->current_button, app->notifications);
        }
        handled = true;
    } else {
        with_view_model(
            app->remote_view,
            RemoteViewModel* model,
            {
                const RemoteButtonDef* btn_def = &button_defs[model->current_button];
                if(model->current_button == Button_Enter) {
                    // Special D-Pad navigation when "OK" is selected
                    switch(event->key) {
                    case InputKeyUp: // Physical Up -> UI Up
                        model->current_button = Button_Up;
                        break;
                    case InputKeyDown: // Physical Down -> UI Down
                        model->current_button = Button_Down;
                        break;
                    case InputKeyLeft: // Physical Left -> UI Left
                        model->current_button = Button_Left;
                        break;
                    case InputKeyRight: // Physical Right -> UI Right
                        model->current_button = Button_Right;
                        break;
                    default:
                        break;
                    }
                } else {
                    // Standard navigation for all other buttons
                    switch(event->key) {
                    case InputKeyUp: // Physical Up -> UI Up
                        model->current_button = btn_def->nav_up;
                        break;
                    case InputKeyDown: // Physical Down -> UI Down
                        model->current_button = btn_def->nav_down;
                        break;
                    case InputKeyLeft: // Physical Left -> UI Left (column change)
                        model->current_button = btn_def->nav_left;
                        break;
                    case InputKeyRight: // Physical Right -> UI Right (column change)
                        model->current_button = btn_def->nav_right;
                        break;
                    default:
                        break;
                    }
                }
            },
            true);
        handled = true;
    }

    return handled;
}

/**
 * @brief Transmits the selected IR code using the SDK library.
 * @param button The button that was pressed.
 * @param notifications Notification app instance for vibration feedback.
 */
static void send_ir_code(TvButton button, NotificationApp* notifications) {
    notification_message(notifications, &sequence_single_vibro);
    notification_message(notifications, &sequence_blink_magenta_10);

    uint8_t address = 0x07; // Samsung address is typically 0x07
    uint8_t command;

    switch(button) {
    case Button_Power:
        command = 0x02;
        break;
    case Button_Volume_Up:
        command = 0x07;
        break;
    case Button_Volume_Down:
        command = 0x0B;
        break;
    case Button_Channel_Up:
        command = 0x12;
        break;
    case Button_Channel_Down:
        command = 0x10;
        break;
    case Button_Left:
        command = 0x65;
        break;
    case Button_Right:
        command = 0x62;
        break;
    case Button_Up:
        command = 0x60;
        break;
    case Button_Down:
        command = 0x61;
        break;
    case Button_Return:
        command = 0x58;
        break;
    case Button_Enter:
        command = 0x68;
        break;
    case Button_Mute:
        command = 0x0F;
        break;
    case Button_Netflix:
        command = 0xFB;
        break;
    case Button_Amazon:
        command = 0xF7;
        break;
    default:
        notification_message(notifications, &sequence_reset_rgb);
        return;
    }

    InfraredSignal* signal = infrared_signal_alloc();
    furi_check(signal);
    InfraredMessage message = {
        .protocol = InfraredProtocolSamsung32, .address = address, .command = command, .repeat = false};
    infrared_signal_set_message(signal, &message);
    infrared_signal_transmit(signal);
    infrared_signal_free(signal);

    furi_delay_ms(50);
    notification_message(notifications, &sequence_reset_rgb);
}

/**
 * @brief Allocates and initializes the application.
 * @return Pointer to the allocated App structure.
 */
static App* app_alloc() {
    App* app = malloc(sizeof(App));
    app->current_view = AppViewRemote; // Initialize the current view state

    app->view_dispatcher = view_dispatcher_alloc();
    view_dispatcher_set_event_callback_context(app->view_dispatcher, app);

    // Remote View
    app->remote_view = view_alloc();
    view_set_orientation(app->remote_view, ViewOrientationVertical);
    view_set_context(app->remote_view, app);
    view_allocate_model(app->remote_view, ViewModelTypeLockFree, sizeof(RemoteViewModel));
    with_view_model(
        app->remote_view,
        RemoteViewModel* model,
        { model->current_button = Button_Power; },
        true);
    view_set_draw_callback(app->remote_view, app_draw_callback);
    view_set_input_callback(app->remote_view, app_input_callback);
    view_dispatcher_add_view(app->view_dispatcher, AppViewRemote, app->remote_view);

    // About Widget
    app->about_widget = widget_alloc();
    widget_add_text_scroll_element(
        app->about_widget,
        0,
        0,
        128,
        64,
        "Samsung TV Remote\n\n"
        "Author: Tyler Berndt\n"
        "Website: https://purplefox.io\n"
        "GitHub: github.com/purplefox-io/flipper-samsung-remote\n\n"
        "Press the OK button to go back to the remote screen. ");
    // Set a custom input callback to handle OK and disable Back
    view_set_input_callback(widget_get_view(app->about_widget), about_widget_input_callback);
    view_set_context(widget_get_view(app->about_widget), app);
    view_dispatcher_add_view(
        app->view_dispatcher, AppViewAbout, widget_get_view(app->about_widget));

    // GUI
    Gui* gui = furi_record_open(RECORD_GUI);
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui, ViewDispatcherTypeFullscreen);
    view_dispatcher_switch_to_view(app->view_dispatcher, AppViewRemote);

    // Notifications
    app->notifications = furi_record_open(RECORD_NOTIFICATION);
    notification_message(app->notifications, &sequence_display_backlight_enforce_on);

    return app;
}

/**
 * @brief Frees all application resources.
 * @param app Pointer to the App structure to free.
 */
static void app_free(App* app) {
    furi_assert(app);

    notification_message(app->notifications, &sequence_display_backlight_enforce_auto);
    furi_record_close(RECORD_NOTIFICATION);

    view_dispatcher_remove_view(app->view_dispatcher, AppViewRemote);
    view_free(app->remote_view);
    view_dispatcher_remove_view(app->view_dispatcher, AppViewAbout);
    widget_free(app->about_widget);

    view_dispatcher_free(app->view_dispatcher);
    furi_record_close(RECORD_GUI);
    free(app);
}

// --- Navigation Callbacks ---

/**
 * @brief Handles the input when on the about screen.
 * @param event The input event.
 * @param context The application context.
 * @return True if the event was handled, false otherwise.
 */
static bool about_widget_input_callback(InputEvent* event, void* context) {
    App* app = context;
    bool handled = false;

    if(event->type == InputTypeShort) {
        if(event->key == InputKeyOk) {
            // Switch back to the remote view
            app->current_view = AppViewRemote;
            view_dispatcher_switch_to_view(app->view_dispatcher, AppViewRemote);
            handled = true;
        } else if(event->key == InputKeyBack) {
            // Consume the back event and do nothing to prevent crashing
            handled = true;
        }
    }
    // Let the default widget handler take care of Up/Down for scrolling
    return handled;
}

/**
 * @brief Main entry point for the application.
 * @param p Unused parameter.
 * @return 0 on success.
 */
int32_t samsung_remote_app(void* p) {
    UNUSED(p);
    App* app = app_alloc();
    view_dispatcher_run(app->view_dispatcher);
    app_free(app);
    return 0;
}